FUNCTION FC215 : Void

TITLE = 'Scan manual pos'
//
// Baustein-Kommentar ...
//
VERSION : '1.0'
AUTHOR  : Broecker
NAME    : ManPos
FAMILY  : Scan

// Bausteinparameter
VAR_INPUT
    // Eingangsparameter
    BridgeNo        :   INT;        // Bridge position no
    PositionNo      :   INT;        // Positions number
    PositionDB      :   INT;        // DB Number of Positions

    ActualPosition  :   DINT;
    PositionMin     :   DINT;
    PositionMax     :   DINT;

   END_VAR

VAR_OUTPUT
    // Ausgangsparameter 
    PrevPosition    :   DINT;
    NextPosition    :   DINT;
    FirstPosition   :   DINT;
    LastPosition    :   DINT;
    
    Error           :   WORD;       
END_VAR

VAR_TEMP
    // temporäre Variablen
    i               :   INT;
    value           :   DINT;
    
    DB_No           :   WORD;
    DB_Length       :   WORD;
    DB_WP           :   BOOL;
    RETURN_Value    :   INT;  
END_VAR

    // Anweisungsteil

    Error := w#16#00;
    
    PrevPosition := 0;
    NextPosition := 0;
    FirstPosition := 0;
    LastPosition := 0;
    
    DB_No := INT_TO_WORD(PositionDB);
    RETURN_Value := TEST_DB(DB_NUMBER := DB_No, // IN: WORD
                            DB_LENGTH := DB_Length, // OUT: WORD
                            WRITE_PROT := DB_WP // OUT: BOOL
                           ); // INT
    // Baustein existiert ?                         
    IF(RETURN_Value <> 0) then                   
        Error := w#16#01;
        RETURN;
    END_IF;                         
    // Bausteinlänge richtig?  
    IF(DB_Length <> w#16#01E4) then                   
        Error := w#16#02;
        RETURN;
    END_IF;
    // Position gültig ?
    IF((ActualPosition < PositionMin) OR (ActualPosition > PositionMax)) THEN                   
        Error := w#16#03;
        RETURN;
    END_IF;
           
    FOR i := 0 TO (PositionNo - 1) BY 1 DO
        value := DWORD_TO_DINT(WORD_TO_BLOCK_DB(INT_TO_WORD(PositionDB)).DD[i * 4 + ((BridgeNo - 1) * 44)]);
        IF((value > PositionMin) AND (value < PositionMax)) THEN
            // minimal
            IF((value < FirstPosition) OR (FirstPosition = 0)) THEN
                FirstPosition := value;
            END_IF;
            // maximal
            IF(value > LastPosition) THEN
                LastPosition := value;
            END_IF; 
        END_IF;        
    END_FOR;
   
    // Position gültig im Bereich?
    IF((ActualPosition + 5 < FirstPosition) OR (ActualPosition - 5 > LastPosition)) THEN                   
        Error := w#16#04;
        RETURN;
    END_IF;
         
    FOR i := 0 TO (PositionNo - 1) BY 1 DO
        value := DWORD_TO_DINT(WORD_TO_BLOCK_DB(INT_TO_WORD(PositionDB)).DD[i * 4 + ((BridgeNo - 1) * 44)]);         
        IF((value >= PositionMin) AND (value <= PositionMax)) THEN
            // positions
            IF((value < ActualPosition - 10) AND (value > PrevPosition)) THEN
                PrevPosition := value;
            END_IF;
            IF((value > ActualPosition + 10) AND ((value < NextPosition) OR (NextPosition = 0))) THEN
                NextPosition := value;
            END_IF;
        END_IF;        
    END_FOR;
    
    // nothing found ???
    IF(PrevPosition = 0) THEN
        PrevPosition := FirstPosition;
    END_IF;    
    IF(NextPosition = 0) THEN
        NextPosition := LastPosition;
    END_IF;   
     
END_FUNCTION

